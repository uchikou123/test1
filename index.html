<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>系统接入中... | Cyber Christmas</title>
    <style>
        /* 页面基础样式：全屏黑底，无滚动条 */
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        
        /* 加载提示文字 */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ff00; font-size: 14px; pointer-events: none;
            text-shadow: 0 0 10px #00ff00; animation: blink 1s infinite;
        }
        
        /* 简单的打字机闪烁动画 */
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        /* 签名/祝福语样式 */
        #ui-layer {
            position: absolute; bottom: 30px; left: 0; width: 100%; text-align: center;
            color: rgba(0, 255, 255, 0.7); pointer-events: none; font-size: 12px;
            text-transform: uppercase; letter-spacing: 2px;
            text-shadow: 0 0 5px cyan;
        }
    </style>
</head>
<body>
    <div id="loading">INITIALIZING NEURAL LINK...</div>
    <div id="ui-layer">Merry Cyber-Christmas // 2024</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. 初始化场景 (Scene Setup) ---
        const scene = new THREE.Scene();
        // 添加赛博风格的迷雾，让远处的粒子隐没在黑暗中
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 100;
        camera.position.y = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // 适配高清屏
        document.body.appendChild(renderer.domElement);

        // --- 2. 创建粒子系统 (Particle System) ---
        // 我们将创建两个层级的粒子：一个是树的主体，一个是周围漂浮的数据尘埃
        
        // 辅助函数：生成螺旋形状的圣诞树粒子坐标
        function createTreeGeometry(particleCount, spread, height) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const colorObj = new THREE.Color();

            for (let i = 0; i < particleCount; i++) {
                // 计算螺旋
                const angle = (i * 0.2) + (Math.PI * 2 * (i / particleCount) * 20); // 旋转角度
                const radius = spread * (1 - i / particleCount); // 半径随高度减小
                const y = (i / particleCount) * height - height / 2; // 高度分布
                
                // 加入随机扰动，让树看起来更自然且有科技感
                const randomX = (Math.random() - 0.5) * 2;
                const randomZ = (Math.random() - 0.5) * 2;
                
                const x = Math.cos(angle) * radius + randomX;
                const z = Math.sin(angle) * radius + randomZ;

                positions.push(x, y, z);

                // 颜色渐变：从底部的青色(Cyan)渐变到顶部的洋红(Magenta)
                // 这种配色非常"赛博朋克"
                const mixRatio = i / particleCount;
                colorObj.setHSL(0.5 + mixRatio * 0.3, 1.0, 0.6); 
                colors.push(colorObj.r, colorObj.g, colorObj.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            return geometry;
        }

        // 创建树
        const treeGeo = createTreeGeometry(3000, 30, 80);
        const treeMat = new THREE.PointsMaterial({
            size: 0.8,
            vertexColors: true, // 使用顶点颜色
            blending: THREE.AdditiveBlending, // 叠加混合模式，产生发光效果
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });
        const treeSystem = new THREE.Points(treeGeo, treeMat);
        scene.add(treeSystem);

        // --- 3. 创建背景星尘/数据流 (Background Particles) ---
        const bgGeo = new THREE.BufferGeometry();
        const bgPos = [];
        for(let i=0; i<1000; i++) {
            bgPos.push((Math.random() - 0.5) * 200); // x
            bgPos.push((Math.random() - 0.5) * 200); // y
            bgPos.push((Math.random() - 0.5) * 200); // z
        }
        bgGeo.setAttribute('position', new THREE.Float32BufferAttribute(bgPos, 3));
        const bgMat = new THREE.PointsMaterial({
            color: 0x00ffaa,
            size: 0.4,
            transparent: true,
            opacity: 0.4
        });
        const bgSystem = new THREE.Points(bgGeo, bgMat);
        scene.add(bgSystem);

        // --- 4. 交互与动画 (Interaction & Animation) ---
        
        // 鼠标/触摸交互
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;

        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX) * 0.05;
            mouseY = (event.clientY - windowHalfY) * 0.05;
        });

        // 隐藏加载文字
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
        }, 1000);

        // 动画循环
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();

            // 1. 树的自转
            treeSystem.rotation.y -= 0.005; 
            
            // 2. 树的“呼吸”效果 (微微的上下浮动和缩放)
            const pulse = Math.sin(time * 2) * 0.02 + 1;
            treeSystem.scale.set(pulse, pulse, pulse);

            // 3. 背景粒子的漂浮
            bgSystem.rotation.y += 0.002;
            bgSystem.rotation.x += 0.001;

            // 4. 摄像机跟随鼠标带来的视差效果
            targetX = mouseX * 0.5;
            targetY = mouseY * 0.5;
            
            camera.position.x += (targetX - camera.position.x) * 0.05;
            camera.position.y += (-targetY + 20 - camera.position.y) * 0.05; // +20是保持基础高度
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        // 窗口大小调整适配
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
