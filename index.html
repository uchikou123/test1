<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>系统接入中... | Cyber Christmas 2.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        #ui-layer { position: absolute; bottom: 30px; left: 0; width: 100%; text-align: center; color: rgba(0, 255, 255, 0.7); pointer-events: none; font-size: 12px; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 5px cyan; }
    </style>
</head>
<body>
    <div id="ui-layer">System Online // Merry Cyber-Christmas 2024</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. 初始化场景 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 100;
        camera.position.y = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        const clock = new THREE.Clock();
        const loader = new THREE.TextureLoader();

        // --- 2. 优化：创建赛博圣诞树 (Fractal Mesh Tree) ---

        // 核心：使用圆锥体几何体，并叠加发光材质
        function createCyberTree() {
            const treeGroup = new THREE.Group();
            const segments = 5; // 圣诞树的层数
            const height = 100;

            for (let i = 0; i < segments; i++) {
                const radiusBottom = 30 * (1 - i / segments);
                const radiusTop = 30 * (1 - (i + 1) / segments) * 0.8;
                const coneHeight = height / segments;

                // 几何体：圆锥体
                const geometry = new THREE.ConeGeometry(radiusBottom, coneHeight, 32); 
                
                // 材质：赛博发光材质 (基础蓝色，产生霓虹效果)
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ffff, // 青色，赛博风
                    wireframe: true, // 关键：只显示线框，更有科技感
                    transparent: true,
                    opacity: 0.2 // 透明度降低，形成结构骨架
                });

                // 几何体：圆环，作为发光灯带
                const ringGeo = new THREE.TorusGeometry(radiusBottom * 0.8, 0.5, 8, 50);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff, // 洋红，与青色形成互补的赛博配色
                    blending: THREE.AdditiveBlending, // 叠加混合模式，产生高亮发光
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2; // 旋转到水平
                ring.position.y = coneHeight / 2;

                const cone = new THREE.Mesh(geometry, material);
                cone.add(ring); // 将圆环灯带添加到圆锥上

                // 设置圆锥位置
                cone.position.y = (i * coneHeight) - height / 2 + coneHeight / 2;
                treeGroup.add(cone);
            }
            treeGroup.position.y = -20; // 调整树的位置，让底部在视野中央
            return treeGroup;
        }

        const cyberTree = createCyberTree();
        scene.add(cyberTree);


        // --- 3. 优化：创建雪花粒子系统 (Texture-Mapped Particles) ---

        function createSnowParticles() {
            const particleCount = 2000;
            const range = 200; // 粒子分布范围
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                // 随机位置
                positions.push(
                    (Math.random() - 0.5) * range, // x
                    Math.random() * range, // y (从顶部开始落下)
                    (Math.random() - 0.5) * range // z
                );
                // 随机速度
                velocities.push(
                    (Math.random() - 0.5) * 0.1, // x方向微风
                    -(Math.random() * 0.2 + 0.1), // 稳定的下降速度
                    (Math.random() - 0.5) * 0.1 // z方向微风
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

            // 加载雪花贴图，注意路径 `spark.png`
            const particleTexture = loader.load('./spark.png', 
                () => console.log('Snow texture loaded.'),
                undefined,
                (err) => console.error('Error loading spark.png. Defaulting to circle.', err)
            );

            // 材质：关键在于使用贴图和 AdditiveBlending
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2, // 粒子大小适中
                map: particleTexture, // 贴图让粒子呈现雪花或光晕形状
                blending: THREE.AdditiveBlending, // 叠加模式产生光晕效果
                transparent: true,
                depthWrite: false,
                opacity: 0.8
            });

            return new THREE.Points(geometry, material);
        }

        const snowSystem = createSnowParticles();
        scene.add(snowSystem);


        // --- 4. 动画循环与更新 ---
        
        let mouseX = 0;
        let mouseY = 0;
        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX) * 0.05;
            mouseY = (event.clientY - windowHalfY) * 0.05;
        });

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            
            // 1. 树的动画：慢速、连续旋转
            cyberTree.rotation.y += 0.005; 
            
            // 2. 摄像机跟随鼠标带来的视差效果 (不变)
            camera.position.x += (mouseX * 0.5 - camera.position.x) * 0.05;
            camera.position.y += (-mouseY * 0.5 + 20 - camera.position.y) * 0.05;
            camera.lookAt(scene.position);


            // 3. 雪花粒子运动更新 (关键优化点)
            const positions = snowSystem.geometry.attributes.position.array;
            const velocities = snowSystem.geometry.attributes.velocity.array;
            const range = 200;

            for (let i = 0; i < positions.length; i += 3) {
                // 应用速度
                positions[i] += velocities[i];     // X
                positions[i + 1] += velocities[i + 1]; // Y
                positions[i + 2] += velocities[i + 2]; // Z

                // Y轴边界检测：如果雪花落到底部，将它重新放回顶部
                if (positions[i + 1] < -range / 2) {
                    positions[i + 1] = range / 2;
                    positions[i] = (Math.random() - 0.5) * range; // 随机X
                    positions[i + 2] = (Math.random() - 0.5) * range; // 随机Z
                }
            }

            // 通知 Three.js 几何体的属性已经发生变化，需要重新渲染
            snowSystem.geometry.attributes.position.needsUpdate = true;
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
